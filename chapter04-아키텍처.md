# 04 아키텍처
## 4.1 MySQL 엔진 아키텍처
### 4.1.1 MySQL의 전체 구조
- 구성
  - MySQL 엔진 (두뇌 역할) + 스토리지 엔진 (손발 역할)
- MySQL 엔진
  - 클라이언트 접속 및 쿼리 요청 처리하는 커넥션 핸들러
  - SQL파서 및 전처리기
  - 쿼리 최적화된 실행을 위한 옵티마이저
  - 표준 SQL(ANSI SQL) 문법 지원
- 스토리지 엔진 : 
  - 디스크 스토리지 저장
  - 디스트 스토리지로부터 데이터 읽어옴 
- 4.1.1.3 핸들러 API
  - MySQL 엔진 <> 스토리지 엔진 간 데이터를 쓰기, 읽기 요청할 때 사용되는 API
### 4.1.2 MySQL 쓰레딩 구조
- 스레드 기반으로 작동하며, 포그라운드(Foreground)스레드와 백그라운드(Background)스레드로 구분한다.
- 포그라운드 스레드(클라이언트 스레드)
  - MySQL 서버에 접속된 클라이언트 수만큼 존재
  - 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
  - 사용자가 작업 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시(Thread cache)로 되돌아 감.
    - 스레드 캐시가 일정 개수 이상이면 캐기가 아닌 스레드 종료시킴
    - 스레드 캐시 유지 가능한 설정 시스템 변수 : ```thread_cache_size```
  - 데이터를 버퍼나 캐시에서 가져오는데, 버퍼/캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업처리
    - MyISAM 테이블은 버퍼/캐시~디스크까지 담당
    - InnoDB 테이블은 버퍼/캐시만 포그라운드, 디스크 기록은 백그라운드가 처리
- 백그래운드 스레드(InnoDB에만 해당)
  - 역할
    - 로그를 디스크로 기록하는 스레드
    - InnoD 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 쓰기 작업은 지연되도, 읽기작업은 지연되면 안되기 때문에 버퍼링으로 일괄 처리하는 기능이 탑재되어있음
    - MyISAM은 버퍼링 기능 X
### 4.1.3 메모리 할당 및 사용 구조
- 글로벌 메모리 영역
  - 클라이언트 스레드 수와 무관
  - 글로벌 영역이 N개여도 모든 스레드 영역에 의해 공유됨
  - 종류
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼
- 로컬 메모리 영역 (=세션 메모리 영역)
  - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
  - 스레드별로 절대 공유되면 안됨
  - 쿼리 용도별로 필요할 때만 공간 할당되고, 필요하지 않을 경우 메모리 공간을 할당조차 안할 수 있음.
  - 종류
    - 정렬버퍼
    - 조인버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼
### 4.1.4 플러그인 스토리지 엔진 모델
- 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위작업이 MySQL 엔진 영역인지, 스토리지 엔진 영역에서 처리되는지 구분할 수 있어야한다.
### 4.1.5 컴포넌트
- 플러그인의 단점을 보완하기 위해 구현
  - 플러그인은 오직 MySQL서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없음.
  - MySQL서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 X)
  - 상호 의존 관계를 설정할 수 없어 초기화가 어려움.
- 
### 4.1.9 스레드 풀
- 동시 처리되는 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 서버 자원 소모 줄이는 것이 목적
- Percona server
  - CPU 코어 개수만큼 스레드 그룹 생성
  - ```thread_pool_size``` 시스템 변수 변경해서 조정
  - 스레드 그룹의 모든 스레드가 일하고 있는 경우 새로운 작업 스레드 (worker thread) or 기다리는지 판단 필요
  - ``` thread_pool_stall_limit ``` : 직금 처리 중인 작업을 끝내지 못하면 새로운 스레드 생성
  - ``` thread_pool_max_threads``` : 전체 스레드 풀의 개수는 이 설정을 넘을 수 없음.
### 4.1.10 트랜잭션 지원 메타데이터
- 테이블 구조정보, 스토어드 프로그램 -> 데이터 딕셔너리 or 메타데이터
- MySQL 8.0 부터는 테이블 구조정보와 스토어드 프로그램 관련 정보를 모두 innoDB 테이블에 저장
  - mysql.ibd 이름의 테이블 스페이스에 저장 => 매우 중요!!!!

## 4.2 InnoDB 스토리지 엔진 아키텍처
- MySQL 스토리지 엔진 중 거의 유일한 레코드 기반 잠금 제공
### 4.2.1 프라이머리 키에 의한 클러스터링
- 프라이머리 키를 기준으로 클러스터링되어 저장 = 프라이머리 키 값 순서대로 디스크에 저장
- 세컨더리 인덱스의 레코드 주소 대신 프라이머리 키 값을 논리적인 주소로 사용 (= 인덱스보다 PK 기준으로 실행계획에 선택될 가능성이 높다.)
### 4.2.2 외래키 지원
- 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요
- 변경할 때 부모, 자식 테이블에 데이터가 있는지 체크하는 작업 필요
  - 잠금이 여러 테이블로 전파되고, 그로 인해 데드락 발생할 때가 많아서 외래키 존재에 주의 필요
- 수동 데이터 적재나 스키마 변경할 때 실패할 가능성이 있다.
  - 부모 테이블과 자식 관계를 명확히해서 순서작업해야함.
  - 급한 경우 ```foreign_key_checks```시스템 변수를 off 설정하면 외래 키 관계 체크 작업을 일시적으로 멈출 수 있다.
    - ```SET foreign_key_cheks = OFF``` (글로벌, 세션 모두 적용 가능)
- 외래키를 가진 부모 테이블 레코드를 삭제하면, 자식 테이블의 레코드도 삭제해야한다.
### 4.2.3 MVCC(Multi Version Concurrency Control)
- 레코드 레벨로 트랜잭션 지원
- 업데이트를 하는 경우 언두 로그에 변경 전 값만 복사
- InnoDB 버퍼 풀과 데이터 파일(디스크)에는 거의 동일한 상태
- 격리수준(Isolation lever)
  - READ_UNCOMMITTED : 커밋이 안되었어도 변경된 데이터를 반환
  - ```READ_COMMITTED```, REPEATABLE_READ, SERIALIZABLE : 버퍼 풀이나 디스크 데이터 대신 언두 영역(변경 전 내용)의 데이터 반환
- 롤백을 실행하면 : 언두 영역에 있는 백업 데이터 InnoDB 버퍼 풀로 복구, 언두 영역 내용 삭제
### 4.2.4 잠금 없는 읽기(Non-Locking Consistent Read)
- READ_UNCOMMITTED, ```READ_COMMITTED```, REPEATABLE_READ : 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않음
- READ_UNCOMMITTED : 커밋 전이어도 변경된 데이터 read
- ```READ_COMMITTED```, REPEATABLE_READ : 커밋 전 데이터를 언두 로그 사용해 read
  - 오랜 동안 트랜잭션이 활성화가 되면, 일관된 데이터를 위해 언두 로그를 계속 유지해야하기 때문
  - 가능한 빨리 롤백이나 커밋으로 트랜을 종료해주는 것이 좋다.⭐️
### 4.2.5 자동 데드락 감지
- InnoDB 스토리지 엔진은 내부적으로 잠금 교착 상태를 Wait-for List 형태로 체크한다.
- 교착 상태에 빠진 경우 언두 로그 양이 더 적은 트랜잭션을 강제 종료 시킨다.
  - 강제 롤백으로 언두 처리하는 양을 적게 가져가는 것.(MySQL 서버 부하 덜 유발)
- MySQL 엔진 관리되는 테이블 데드람 감지 ```innodb_table_locks ```는 되도록 활성화 하자
  - 이걸 안하면 감지가 불확실함
- 동시 처리 트랜잭션이 많아지는 경우 잠금 감지 쓰레드 부하가 더 심해질 수 있음.
  - ```innodb_deadlock_detect```를 끄는 대신, ```innodb_lock_wait_timeout```을 50초 이하로 설정해 활용하자.
  - PK 기반 조회나, 세컨더리 인덱스 기반으로 동시성 높은 처리를 요구하는 경우 추천
### 4.2.7 InnoDB 버퍼풀
- 디스크 데이터 파일, 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업 처리
  - CUD로 인해 랜덤한 디스크 작업을 버퍼풀이 모아서 모아서 처리
#### 4.2.7.1 버퍼 풀의 크기 설정
- MySQL 서버가 사용하는 버퍼 공간(클라이언트 세션이 테이블 레코드 읽고 쓸 때 사용하는 공간)은 설정이 불가능함.
- 최초 InnoDB 버퍼풀 크기는 적절히 작은 값으로 하다가 확장하는 걸 추천
- 버퍼 풀 크기 줄이는 작업은 서비스 영향도가 너무 크므로 하지 않는게 좋다.
- 버퍼 풀 크기를 키우는 것도 크리티컬한 변경이라서, MySQL 서버가 한가할 때 하는 게 좋다.
- 버퍼 풀 인스턴스 (여러 개의 버퍼 풀)
  - 메모리 공간이 40GB 이하 -> 8개 유지
  - 그 이상이면 버퍼 풀 인스턴스 당 5GB 설정 추천
#### 4.2.7.3 버퍼 풀과 리두 로그
- 버퍼 풀 : 서버 성능 향상을 위한 데이터 캐시, 쓰기 버퍼링
  - 버퍼 풀 메모리 공간만 늘리는 건 -> 데이터 캐시 기능만 향상
- 쓰기 버퍼링 기능 향상을 하려면 ? 버퍼 풀, 리두 로그 관계 이해 필요.
- Inno DB 버퍼 풀 : 디스크 읽은 상태로 전혀 변경 되지 않은 클린 페이지 + CUD에 의한 변경된 데이터를 가진 더티 페이지
- 리두 파일 : 재사용 가능 공간 + 재사용 불가능 공간
  - 재사용 불가 = 활성 리두 로그(Active Redo Log)
- 클린 페이지 : 디스크에서 읽은 상태로 전혀 변경되지 않은 페이지
- 더티 페이지 : Insert, update, delete에 의해 변경된 데이터를 가진 페이지
#### 4.2.7.4 버퍼 풀 플러시(Flush)
- 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지를 성능 영향없이 디스크에 동기화하기 위한 플러시 2가지 방법
  - 플러시 리스트(Flush_list) 플러시
  - LRU 리스트(LRU_list) 플러시
##### 4.2.7.4.1 플러시 리스트 플러시
- 정의 : 오래전에 변경된 더티 페이지를 디스크로 동기화 하는 방식
  - InnoDB 스토리지 엔진은 주기적으로 Flush_list 플러시 함수를 호출해 플러시 리스트에서 오래전 변경된 더티 페이지 순서대로 디스크 동기화
- 얼마나 많은 더티 페이지를 한번에 순서대로 디스크 동기화 할지는 시스템 변수 활용
- innodb_page_cleaners : 클리너 스레드 개수 조정하는 시스템 변수
  - 클리너 스레드(Cleaner Thread) : 더티 페이지를 디스크로 동기화하는 스레드
  - 버퍼 풀 인스턴스(innodb_buffer_pool_instances) 보다 숫자가 큰 경우 자동으로 인스턴스 값으로 설정됨.
  - 결론 : 가능한 인스턴스 값과 스레드 값은 동일하게 설정한다.
- innodb_max_dirty_pages_pct : 스토리지 엔진에서 더티페이지를 가질 수 있는 비율(%) 설정하는 시스템변수
  - 더티페이지가 많을 수록 디스크 쓰기 폭발(Disk IO Burst) 현상 발생 가능성이 높아진다.
    - 디스크로 기록되는 더티 페이지 개수보다 더 많은 더티 페이지가 발생하는 경우 버퍼 풀에 더티 페이지가 계속 증가함.
- innodb_adaptive_flushing_lvm : 일정 수준(비율 %) 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록할 수 있게 설정하는 값
  - 전체 리두 로그 공간에 활성 리두 공간을 얼마나 가져갈지 설정하는 시스템변수
- 어댑티브 플러시(Adaptive flush) : 디스크 I/O 읽고 쓰는 설정값 대신 새로운 알고리즘
  - 어느 정도의 속도로 더티 페이지가 생성되는지 분석하는 것 (= 리두 로그가 어느 정도 속도로 증가하는지 분석)
  - 동작방식 : innodb_adaptive_flushing_lvm 설정값보다 넘어서게 되면 자동 작동한다.
#### 4.2.7.5 버퍼 풀 상태 백업 및 복구
- InnoDB 서버 버퍼풀은 쿼리 성능에 굉장히 영향을 많이 줌
- 워밍 업 : 디스크의 데이터가 버퍼 풀에 적재되어있는 상태
  - 몇십 배의 쿼리 처리 속도를 보인다.
- MySQL 5.6 버전부터 버퍼 풀 덤프 및 적재 기능 도입됨.
- ```innodb_buffer_pool_load_now``` 시스템 변수로 백업된 버퍼 풀 상태 복구 가능
  - 복구하는 작업은 상당히 많은 디스크 읽기를 요구한다.
  - 복구가 실행 중일 땐 서비스 재개하지 않는 것이 좋다.
#### 4.2.7.6 버퍼 풀의 적재 내용 확인
- 버퍼 풀이 큰 경우 테이블 조회가 상당히 큰 부하가 발생해 서비스용으로 버퍼 풀 상태 확인하는게 불가능했음.
- MySQL 8.0 부터는 information_schema 의 innodb_cached_index 테이블로 
  - 인덱스별 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인 가능

### 4.2.8 Double Write Buffer
- 배경
  - InnoDB 스토리지 엔진의 리두 로그는 공간 낭비를 방지하기 위해 페이지의 변경되 내용만 기록한다.
  - 스토리지 엔진에서 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생하면 페이지 내용 복구가 안된다. 
    - 파셜 페이지(Partial-page), 톤 페이지(Torn-page) : 페이지가 일부만 기록되는 현상
  - 이런 문제를 방지하기 위해 Double-Write 기법을 사용한다.
- 작동방식
  - 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 묶어서 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 페이지들을 기록
  - 스토리지 엔진은 각 더티 파일의 적당한 위치에 하나씩 랜덤으로 쓰기 진행
- SSD처럼 랜덤IO가 많이 이루어지는 경우에 부담될 수 있지만 데이터 안정성을 위해 활성화 하는게 좋다.
- 시스템 변수 : ```innodb_doublewrite```

### 4.2.9 언두 로그
- 배경
  - 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
  - 이 때 백업된 데이터를 언두 로그(Undo log)라 함.
- 사용되는 방법
  - 트랜잭션 보장(롤백 예비용) : 트랜잭션 롤백 시 트랜잭션 도중에 변경된 데이터를 변경 전 데이터로 복구할 때 사용.
  - 격리 수준 보장(+ 높은 동시성 제공) : 특정 커넥션에서 데이터 변경하는 경우 트랜잭션 격리 수준에 맞게 언두 로그에 백업 데이터를 조회함.
#### 4.2.9.1 언두 로그 모니터링
- 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는건 아니다.
  - 다른 트랜잭션에서 사용해야하는 경우 언두 로그는 누적으로 저장된다.
- MySQL 8.0이 되면서 언두 로그 공간 제어가 가능해졌다.
  - 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간 줄이기 가능
  - 서버가 필요한 시점에 사용공간을 자동으로 줄일 수 있음
- MySQL 서버의 언두 로그가 얼마나 증가했는지(급증 여부) 항상 모니터링하는게 좋다. 
  - ```select count from information_schema.innodb_metrics``` : 언두 로그 건수 확인
#### 4.2.9.2 언두 테이블스페이스 관리
- 언두 테이블스페이스 : 언두 로그가 저장되는 공간
- MySQL 8.0.14부터는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 저장되도록 개선되었음.

### 4.2.10 체인지 버퍼
- 체인지 버퍼 : 레코드가 Insert, update 됐을 때 데이터 파일을 변경하는 작업 + 해당 테이블에 포함된 인덱스 업데이트하는 작업이 필요
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트 하지만, 없으면 디스크로부터 읽어와서 업데이트 해야한다.
  - 이걸 바로 실행하지 않고 임시공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 변경됨
  - 이 때의 임시공간이 체인지 버퍼(Change Buffer)
- 하지만 결과를 전달하기 전에 중복 여부를 체크해야하는 유니크 인덱스는 체인지 버퍼풀을 사용할 수 없음.
- 체인지 버퍼에 임시 저장된 인덱스 레코드 조강은 이후 백그라운드 스레드에 의해 병함됨
  - 머지 스레드 (Merge thread)
- MySQL 8.0부터는 Insert 외에 Delete, update로 인한 키 추가 및 삭제도 버퍼링 할 수 있게 됨.

### 4.2.11 리두 로그 및 로그 버퍼
- 배경
  - 트랜잭션의 4가지 요소인 ACID 중에서 D(Durable)에 해당하는 영속성과 연관
  - MySQL 서버가 비정상적으로 종료됐을 떄 데이터 파일에 기록되지 못한 데이터를 잃지 못하게 하는 안전 장치
  - 쓰기보다 읽기성능을 고려한 자료구조라서 파일 쓰기는 디스크의 랜덤 액세스이고 큰 비용이 필요하다. => 비용이 낮은 자료 구조의 리두 로그 이용 
- 동작 방식
  - 데이터 변경 내용을 로그로 먼저 기록
  - 리두 로그를 버퍼링할 수 있는 InnoDB 버퍼 풀이나 리두 로그를 버퍼링할 수 있는 로그 버퍼 같은 자료 구조 가지고 있음.
- 사용 방법
  - 커밋됐지만 데이터 파일에 기록되지 않은 데이터
    - 리두 로그에 저장된 데이터를 데이터 파일에 복사
  - 롤백됐지만 데이터 파일에 이미 기록된 데이터 
    - 변경되기 전 데이터를 가진 언두 로그 내용 + 변경이 커밋, 롤백, 트랜잭션 중간 상태였는지 리두 로그 파일로 확인
- 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 걸 권장
  - ```innodb_flush_log_at_trx_commit```
  - 0 : 1초에 한번씩 리두 로그를 디스크로 기록(write)하고 동기화(sync)함
    - 서버가 비정상 졸료되면 1초 동안 트랜잭션은 커밋되도 데이터는 사라질 수 있음
  - 1 : 매번 트랜잭션이 커밋될 때마다 디스크로 기록 및 동기화까지 수행, 트랜잭션이 커밋되면 해당 트랜잭션에서 변경한 데이터는 삭제
  - 2 : 트랜잭션이 커밋될 때마다 디스크로 기록은 되지만, 실질적인 동기화(sync)는 1초에 한번씩 실행
    - 트랜잭션이 커밋되면 변경 내용이 운영체제의 메모리 버퍼로 기록되는 것 보장
    - 단, 서버와 운영체제 모두 비정상적 종료되면 1초 동안의 데이터 유실 가능
- InnoDB 스토리지 엔진의 리두 로그 파일들의 전체 크기는 InnoDB 스토리지 엔진이 가지고 있는 버퍼 풀 효율성을 결정하기 떄문에 신중히 결정해야한다.
#### 4.2.11.1 리두 로그 아카이빙
- MySQL 8.0 부터 InnoDB 스토리지 엔진의 리두 로그를 아카이빙할 수 있는 기능 추가
- 엔터프라이즈 백업, Xtrabackup 툴 :  리두 로그에 쌓인 내용을 계속 추적해 새로 추가된 리두 로그 엔트리를 복사함
- 변경이 너무 많아서 리두 로그가 덮어쓰여도 백업이 실패하지 않게 해줌
#### 4.2.11.2 리두 로그 활성화 및 비활성화
- InnoDB 스토리지 엔진의 리두 로그는 여러 문제로 MySQL서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 트랜잭션 복구를 위해 항상 활성화
- 데이터 파일은 즉시 디스크 동기화 하지 않지만, 리두 로그(트랜잭션 로그)는 항상 디스크로 기록됨.
- MySQL 8.0부터는 리두 로그 비활성화 가능 (데이터 복구나 대용량 데이터를 한번에 적재하는 경우)
  - 되도록 데이터 일부 손실이 괜찮다면 이걸 비활성화하기보다는 ```innodb_flush_log_at_trx_commit```을 0, 2로 설정해서 사용하자 

### 4.2.1.2 어댑티브 해시 인덱스
- innoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
  - ```innodb_adaptive_hash_index``` 로 활성화 선택 가능
- B-Tree 인덱스로 값 찾는 과정이 느린 경우 도와주기 위한 인덱스
  - 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해 레코드가 저장된 데이터 페이지 즉시 찾아감
- 해시 인덱스 : 인덱스 키값 + 데이터 페이지 주소 
  - 인덱스 키 값 : B-Tree 인덱스의 고유번호(id) + B-Tree 인덱스의 실제 키 값
    - 해시 인덱스는 스토리지 엔진에서 하나만 존재하기 때문에 고유번호 필요
  - 데이터 페이지 주소 : 실제 키 값이 저장된 데이터 페이지 주소 
- 성능 도움이 안되는 경우
  - 디스크 읽기가 많은 경우
  - 특정 패턴의 쿼리가 많은 경우 (조인, like 패턴)
  - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
- 성능 향상에 도움 되는 경우
  - 디스크 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
  - 동등 조건 검색(동등 비교, In 연산자)이 많은 경우
  - 쿼리가 데이터 중에서 일부 데이터에만 집중 되는 경우
- 해시 인덱스는 테이블 삭제나 변경에도 영향이 크다.
  - 해당 테이블이 가진 모든데이터 페이지의 내용을 인덱스에서 제거해야한다.

## 4.4 MySQL 로그 파일
### 4.4.1 에러 로그 파일
- MySQL 설정 파일(my.cnf)에서 log_error 파라미터로 정의된 경로에 생성
### 4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)
- general_log_file 파라미터에 쿼리 로그 파일 경로 저장
- 슬로우 쿼리와 다르게 실행되기전 쿼리 요청을 받으면 바로 기록한다.
### 4.4.3 슬로우 쿼리 로그 
- MySQL 서버의 전체적인 성능 저하 검사나 정기적인 점검을 위한 튜닝 때 사용
- 반드시 쿼리가 실행 완료되어야 해당 로그 파일에 기록된다.
- file이나 table로 저장가능하나 결국 CSV 파일로 저장되는 것은 동일하다.
- InnoDB 테이블에만 접근하는 슬로우 쿼리로그에서는 Lock_time 값은 의미있지 않음
- Percona Toolkit의 pt-query-digest 스크립트 활용 추천
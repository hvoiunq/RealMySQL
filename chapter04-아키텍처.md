# 04 아키텍처
## 4.1 MySQL 엔진 아키텍처
### 4.1.1 MySQL의 전체 구조
- 구성
  - MySQL 엔진 (두뇌 역할) + 스토리지 엔진 (손발 역할)
- MySQL 엔진
  - 클라이언트 접속 및 쿼리 요청 처리하는 커넥션 핸들러
  - SQL파서 및 전처리기
  - 쿼리 최적화된 실행을 위한 옵티마이저
  - 표준 SQL(ANSI SQL) 문법 지원
- 스토리지 엔진 : 
  - 디스크 스토리지 저장
  - 디스트 스토리지로부터 데이터 읽어옴 
- 4.1.1.3 핸들러 API
  - MySQL 엔진 <> 스토리지 엔진 간 데이터를 쓰기, 읽기 요청할 때 사용되는 API
### 4.1.2 MySQL 쓰레딩 구조
- 스레드 기반으로 작동하며, 포그라운드(Foreground)스레드와 백그라운드(Background)스레드로 구분한다.
- 포그라운드 스레드(클라이언트 스레드)
  - MySQL 서버에 접속된 클라이언트 수만큼 존재
  - 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
  - 사용자가 작업 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시(Thread cache)로 되돌아 감.
    - 스레드 캐시가 일정 개수 이상이면 캐기가 아닌 스레드 종료시킴
    - 스레드 캐시 유지 가능한 설정 시스템 변수 : ```thread_cache_size```
  - 데이터를 버퍼나 캐시에서 가져오는데, 버퍼/캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업처리
    - MyISAM 테이블은 버퍼/캐시~디스크까지 담당
    - InnoDB 테이블은 버퍼/캐시만 포그라운드, 디스크 기록은 백그라운드가 처리
- 백그래운드 스레드(InnoDB에만 해당)
  - 역할
    - 로그를 디스크로 기록하는 스레드
    - InnoD 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 쓰기 작업은 지연되도, 읽기작업은 지연되면 안되기 때문에 버퍼링으로 일괄 처리하는 기능이 탑재되어있음
    - MyISAM은 버퍼링 기능 X
### 4.1.3 메모리 할당 및 사용 구조
- 글로벌 메모리 영역
  - 클라이언트 스레드 수와 무관
  - 글로벌 영역이 N개여도 모든 스레드 영역에 의해 공유됨
  - 종류
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼
- 로컬 메모리 영역 (=세션 메모리 영역)
  - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
  - 스레드별로 절대 공유되면 안됨
  - 쿼리 용도별로 필요할 때만 공간 할당되고, 필요하지 않을 경우 메모리 공간을 할당조차 안할 수 있음.
  - 종류
    - 정렬버퍼
    - 조인버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼
### 4.1.4 플러그인 스토리지 엔진 모델
- 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위작업이 MySQL 엔진 영역인지, 스토리지 엔진 영역에서 처리되는지 구분할 수 있어야한다.
### 4.1.5 컴포넌트
- 플러그인의 단점을 보완하기 위해 구현
  - 플러그인은 오직 MySQL서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없음.
  - MySQL서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 X)
  - 상호 의존 관계를 설정할 수 없어 초기화가 어려움.
- 
### 4.1.9 스레드 풀
- 동시 처리되는 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 서버 자원 소모 줄이는 것이 목적
- Percona server
  - CPU 코어 개수만큼 스레드 그룹 생성
  - ```thread_pool_size``` 시스템 변수 변경해서 조정
  - 스레드 그룹의 모든 스레드가 일하고 있는 경우 새로운 작업 스레드 (worker thread) or 기다리는지 판단 필요
  - ``` thread_pool_stall_limit ``` : 직금 처리 중인 작업을 끝내지 못하면 새로운 스레드 생성
  - ``` thread_pool_max_threads``` : 전체 스레드 풀의 개수는 이 설정을 넘을 수 없음.
### 4.1.10 트랜잭션 지원 메타데이터
- 테이블 구조정보, 스토어드 프로그램 -> 데이터 딕셔너리 or 메타데이터
- MySQL 8.0 부터는 테이블 구조정보와 스토어드 프로그램 관련 정보를 모두 innoDB 테이블에 저장
  - mysql.ibd 이름의 테이블 스페이스에 저장 => 매우 중요!!!!

## 4.2 InnoDB 스토리지 엔진 아키텍처
- MySQL 스토리지 엔진 중 거의 유일한 레코드 기반 잠금 제공
### 4.2.1 프라이머리 키에 의한 클러스터링
- 프라이머리 키를 기준으로 클러스터링되어 저장 = 프라이머리 키 값 순서대로 디스크에 저장
- 세컨더리 인덱스의 레코드 주소 대신 프라이머리 키 값을 논리적인 주소로 사용 (= 인덱스보다 PK 기준으로 실행계획에 선택될 가능성이 높다.)
### 4.2.2 외래키 지원
- 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요
- 변경할 때 부모, 자식 테이블에 데이터가 있는지 체크하는 작업 필요
  - 잠금이 여러 테이블로 전파되고, 그로 인해 데드락 발생할 때가 많아서 외래키 존재에 주의 필요
- 수동 데이터 적재나 스키마 변경할 때 실패할 가능성이 있다.
  - 부모 테이블과 자식 관계를 명확히해서 순서작업해야함.
  - 급한 경우 ```foreign_key_checks```시스템 변수를 off 설정하면 외래 키 관계 체크 작업을 일시적으로 멈출 수 있다.
    - ```SET foreign_key_cheks = OFF``` (글로벌, 세션 모두 적용 가능)
- 외래키를 가진 부모 테이블 레코드를 삭제하면, 자식 테이블의 레코드도 삭제해야한다.
### 4.2.3 MVCC(Multi Version Concurrency Control)
- 레코드 레벨로 트랜잭션 지원
- 업데이트를 하는 경우 언두 로그에 변경 전 값만 복사
- InnoDB 버퍼 풀과 데이터 파일(디스크)에는 거의 동일한 상태
- 격리수준(Isolation lever)
  - READ_UNCOMMITTED : 커밋이 안되었어도 변경된 데이터를 반환
  - ```READ_COMMITTED```, REPEATABLE_READ, SERIALIZABLE : 버퍼 풀이나 디스크 데이터 대신 언두 영역(변경 전 내용)의 데이터 반환
- 롤백을 실행하면 : 언두 영역에 있는 백업 데이터 InnoDB 버퍼 풀로 복구, 언두 영역 내용 삭제
### 4.2.4 잠금 없는 읽기(Non-Locking Consistent Read)
- READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ : 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않음
- READ_UNCOMMITTED : 커밋 전이어도 변경된 데이터 read
- READ_COMMITTED, REPEATABLE_READ : 커밋 전 데이터를 언두 로그 사용해 read
  - 오랜 동안 트랜잭션이 활성화가 되면, 일관된 데이터를 위해 언두 로그를 계속 유지해야하기 때문
  - 가능한 빨리 롤백이나 커밋으로 트랜을 종료해주는 것이 좋다.⭐️
### 4.2.5 자동 데드락 감지
- InnoDB 스토리지 엔진은 내부적으로 잠금 교착 상태를 Wait-for List 형태로 체크한다.
- 교착 상태에 빠진 경우 언두 로그 양이 더 적은 트랜잭션을 강제 종료 시킨다.
  - 강제 롤백으로 언두 처리하는 양을 적게 가져가는 것.(MySQL 서버 부하 덜 유발)
- MySQL 엔진 관리되는 테이블 데드람 감지 ```innodb_table_locks ```는 되도록 활성화 하자
  - 이걸 안하면 감지가 불확실함
- 동시 처리 트랜잭션이 많아지는 경우 잠금 감지 쓰레드 부하가 더 심해질 수 있음.
  - ```innodb_deadlock_detect```를 끄는 대신, ```innodb_lock_wait_timeout```을 50초 이하로 설정해 활용하자.
  - PK 기반 조회나, 세컨더리 인덱스 기반으로 동시성 높은 처리를 요구하는 경우 추천
### 4.2.7 InnoDB 버퍼풀
- 디스크 데이터 파일, 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업 처리
  - CUD로 인해 랜덤한 디스크 작업을 버퍼풀이 모아서 모아서 처리
#### 4.2.7.1 버퍼 풀의 크기 설정
- MySQL 서버가 사용하는 버퍼 공간(클라이언트 세션이 테이블 레코드 읽고 쓸 때 사용하는 공간)은 설정이 불가능함.
- 최초 InnoDB 버퍼풀 크기는 적절히 작은 값으로 하다가 확장하는 걸 추천
- 버퍼 풀 크기 줄이는 작업은 서비스 영향도가 너무 크므로 하지 않는게 좋다.
- 버퍼 풀 크기를 키우는 것도 크리티컬한 변경이라서, MySQL 서버가 한가할 때 하는 게 좋다.
- 버퍼 풀 인스턴스 (여러 개의 버퍼 풀)
  - 메모리 공간이 40GB 이하 -> 8개 유지
  - 그 이상이면 버퍼 풀 인스턴스 당 5GB 설정 추천
#### 4.2.7.3 버퍼 풀과 리두 로그
- 버퍼 풀 : 서버 성능 향상을 위한 데이터 캐시, 쓰기 버퍼링
  - 버퍼 풀 메모리 공간만 늘리는 건 -> 데이터 캐시 기능만 향상
- 쓰기 버퍼링 기능 향상을 하려면 ? 버퍼 풀, 리두 로그 관계 이해 필요.
- Inno DB 버퍼 풀 : 디스크 읽은 상태로 전혀 변경 되지 않은 클린 페이지 + CUD에 의한 변경된 데이터를 가진 더티 페이지
- 리두 파일 : 재사용 가능 공간 + 재사용 불가능 공간
  - 재사용 불가 = 활성 리두 로그(Active Redo Log)
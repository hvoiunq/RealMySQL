## 05 | 트랜잭션과 잠금
- MySQL의 동시성에 영향을 미치는 잠금(Lock), 트랜잭션, 트랜잭션 격리 수준(Isolation level)에 대한 내용
- 잠금(Lock) : 동시성 제어하기 위한 기능
- 트랜잭션 : 작업의 완전성 보장 기능(일부만 적용되는 것을 방지)
- 격리 수준 : 하나의 트랜잭션 내 or 여러 트랜잭션 간 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

### 5.1 트랜잭션
### 5.1.1 MySQL에서의 트랜잭션
- 하나의 논리적인 작업 셋에 몇 개의 쿼리와 상관없이 
  - 논리적인 작업 셋 자체가 100% 적용되거나(COMMIT)
  - 아무것도 적용되지 않는 것(ROLLBACK or 트랜잭션 ROLLBACK 시키는 오류 발생)을 보장해주는 것
### 5.1.2 주의사항
- 네트워크를 통해 원격 서버와 통신하는 등의 작업은 DBMS 트랜잭션 내에서 반드시 제거하는 것이 좋다.
- 단순 조회작업도 트랜잭션에 포함시킬 필요가 없다.
- 결론
  - 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야한다.

### 5.2 MySQL 엔진의 잠금
- 잠금의 종류
  - 스토리지 엔진 레벨
    - 스토리지 엔진 간 상호 영향을 미치지 않는다.
  - MySQL 엔진 레벨
    - 스토리지 엔진을 제외한 나머지
    - 모든 스토리지 엔진에 영향을 끼친다.
- MySQL 엔진 종류
  - 테이블 데이터 동기화를 위한 테이블 락
  - 테이블 구조를 잠그는 메타데이터 락
  - 사용자 필요에 맞게 네임드 락
### 5.2.1 글로벌 락(GLOBAL_LOCK)
- 잠금 범위가 가장 큼(MYSQL 서버 전체에 영향)
- InnoDB 스토리지 엔진은 트랜잭션을 지원하기 떄문에 모든 데이터 변경 작업을 멈출 필요가 없다.
  - MySQL 8.0 : Xtrabackup, Enterprise 
  - Backup 툴 등 더 가볍고 안정적인 백업 락 도입됨
- MySQL 서버는 소스 서버(Source Server) 와 레플리카 서버(Replica server)로 구성
  - 백업은 레플리카에서 진행
### 5.2.2 테이블 락(Table Lock)
- 개별 테이블 단위로 설정되는 잠금
- 명시적, 묵시적 방법으로 락 획득 가능
- 애플리케이션에서 해당 락을 이용할 일은 거의 없음.
### 5.2.3 네임드 락(Named Lock)
- GET_LOCK() 함수로 임의의 문자열에 대해 잠금 설정
- 한번에 많은 레코드를 변경하는 경우에 활용하면 좋음
### 5.2.4 메타데이터 락(Metadata Lock)
- 데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금

## 5.3 InnoDB 스토리지 엔진 잠금
- 레코드 기반 잠금
- information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 라는 테이블을 조인해 조회시
  - 어떤 트랜잭션이 잠금을 대기하고 있고
  - 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있고
  - 장시간 잠금을 가지고 있는 클라이언트를 찾아서 종료할 수 있다.
### 5.3.1.1 레코드 락
- InnoDB 스토리지 엔진은 레코드 자체가 아닌 인덱스의 레코드를 잠금다.
- 인덱스가 하나도 없더라도 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정.
- 대부분 보조 인덱스를 이용해 넥스트 키 락이나 갭 락을 이용하지만, PK나 UK에 의한 변경은 레코드 자체에 대해서만 락!
### 5.3.1.2. 갭 락
- 레코드와 바로 인접한 레코드 사이의 간격을 잠그는 것.
- 레코드 사이 간격에 새로운 레코드 생성(insert)를 제어함.
### 5.3.1.3 넥스트 키 락
- 레코드 락과 갭 락을 합쳐 놓은 형태
- STATEMENT 포맷의 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장해주는 것.
- MySQL 8.0 : ROW 포맷의 바이너리 로그가 기본 설정
### 5.3.1.4 자동 증가 락
- AUTO_INCREMENT 컬럼 속성 : 자동 증가하는 숫자 값을 추출(채번)
- INSERT, REPLACE 쿼리 문장에서만 필요
- 트랜잭션과 관계없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨.
- 명시적으로 획득하고 해제하는 방법은 없음.
- 자동 증가락의 작동 방식 설정(```innodb_autoinc_lock_mode```)
  - 0 : 모든 INSERT 문장 자동 증가 락
  - 1 : INSERT 하는 레코드 건수가 정확히 예측되는 경우 자동 증가 락 대신 래치(뮤텍스) 이용
    - 대량 건이 수행되면 자동 증가 값을 한 번에 할당받아서 INSERT되는 레코드에 사용.
    - 남는 자동 증가 값은 폐기된다(= 대량 insert 이후 insert되는 레코드의 자동 증가 값은 연속되지 않을 수 있음.)
  - 2 : 절대 자동 증가 락을 걸지 않음
    - 래치(뮤텍스)사용
    - 하나의 insert여도 연속된 자동 증가 값 보장하지 않음.(인터리빙 모드 - interleaved mode)
    - 자동 증가 기능은 유니크한 값이 생성된다는 것만 보장한다.
- MySQL 8.0 부터는 ```innodb_autoinc_lock_mode``` 기본값이 2로 바뀌었다.
  - STATEMENT 포맷의 바이너리라면 1로 변경해서 사용할 것 
- insert 쿼리가 실패해도 한번 증가된 AUTO_INCREMENT 값은 다시 줄어들지 않는다. 
### 5.3.2 인덱스와 잠금
- InnoDB 잠금은 레코드 잠금이 아닌 인덱스 잠금이다.
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락으로 걸어야한다.
- update 문장을 위해 적절한 인덱스가 없으면, 클라이언트간 동시성이 상당히 떨어진다. (매우 주의!!!!!)
- 인덱스가 하나도 없다면?
  - full 스캔을 해야하면서 모든 레코드를 잠구게 된다.
### 5.3.3. 레코드 수준의 잠금 확인 및 해제
- performance_schema의 data_locks와 data_lock_waits 테이블로 잠금과 잠금 대기 순서를 확인할 수 있다.
- 잠금 대기 큐의 내용을 모두 보여준다.

## 5.4 MySQL의 격리 수준
### 5.4.2 READ COMMITTED
- commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- 더티 리드(Dirty read)는 발생하지 않는다.
- 하나의 트랜잭션에서 똑같은 SELECT 쿼리를 실행했을 때 같은 결과를 가져와야한다는 "REPEATABLE READ" 정합성에는 어긋난다.
  - 이런 이유로, 어떤 결과를 가져오게 될 지 정확히 예측할 수 있어야한다.

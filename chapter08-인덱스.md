# 인덱스
## 8.1 디스크 읽기 방식
### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- SSD의 장점 : 기존 HDD 보다 랜덤I/O가 훨씬 빠르다.
- 데이터 베이스 서버에서는 순차 I/O 비중보다는 작은 데이터를 읽고 쓰는 작업인 랜덤I/O 작업이 훨씬 많다.
### 8.1.2 순차I/O와 랜덤 I/O 차이
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하냐에 따라 결정됨.
  - 순차 I/O : 디스크 기록이 필요한 페이지를 모았다가 한번에 처리하는 방식.
  - 랜덤 I/O : 디스크 기록이 필요할 때마다 디스크 헤더를 움직이는 방식 (속도가 느리다.)
- RAID 컨트롤러 : 파일 동기화 작업이 너무 빈번하지 않게 도와주는 캐시 메모리를 장착한 장치.
- 쿼리 튜닝으로 랜덤I/O를 순차 I/O 로 변경할 수는 없다.
  - 랜덤 I/O자체를 줄여주는 것이 튜닝의 목적
  - 즉, 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것이다.
- 인덱스 레인지 스캔 : 주로 랜덤I/O 사용
- 풀 테이블 스캔 : 순차I/O 사용

## 8.2 인덱스란?
- 인덱스 설정 컬럼(들)과 해당 레코드가 저장된 주소를 키-밸류 형태로 저장하고 있다.
- 컬럼 값은 설정된 순서대로 미리 정렬되어 보관된다.
- SortedList 자료 구조
  - 저장되는 값을 항상 정렬된 상태로 유지
  - (장점) 조회 속도가 굉장히 빠르다 
  - (단점) 저장될 때마다 항상 값을 재정렬해야 해서 저장하는 과정이 복잡하고 느림 
  - (<->) ArrayList : 데이터파일 자료구조, 값을 저장되는 순서대로 저장
- 데이터의 저장 속도를 어디까지 희생하고, 읽기 속도를 얼마나 더 빠르게 만들지에 따라 결정해야한다.
- 역할은 프라이머리 키(Primary key), 세컨더리 인덱스(Secondary key) 로 구분할 수 있다.
  - PK는 null값과 중복값을 허용하지 않는다.
  - Secondary key는 PK를 제외한 나머지 모든 인덱스를 말하며, 그 중에서 유니크 인덱스는 PK와 성격이 비슷해 대체 키로도 불린다.
- 데이터 저장방식(알고리즘) : B-Tree 인덱스, Hash 인덱스로 구분된다.
  - B-Tree 인덱스 : 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  - Hash 인덱스 : 칼럼의 값으로 해시값을 계산해 인덱싱하는 알고리즘
    - 검색 속도가 매우 빠르나, 일부 값 검색이나 범위 검색할 때는 사용할 수 없다. ✔️
- 유니크 인덱스
  - 유니크 인덱스에 대해 동등조건으로 검색하는 경우 옵티마이저에게 1건을 찾으면 더 찾지 않아도 된다고 알려주는 효과가 있다.      


## 8.3 B-Tree 인덱스
- B-Tree의 "B" : Binary(이진)의 약자가 아닌 ```Balanced```를 의미

### 8.3.1 구조 및 특성
- 최상위에 ```루트 노드(Root node)``` 
- 가장 하위에 있는 ```리프 노드(Leaf node)```
  - 실제 데이터 레코드를 찾기 위한 주솟값을 저장하고 있음. 
- 루트와 리프 사이에 있는 ```브랜치 노드(Branch node)```
- InnoDB의 레코드 저장방식
  - InnoDB는 데이터 파일의 레코드가 클러스터되어 디스크에 저장되기 때문에, 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
    - 클러스터링이란? 비슷한 값을 최대한 모아서 저장하는 방식
    - 일반적인 RDBMS는 데이터 파일은 순서대로 저장하지 않는다. 삭제된 공간을 재활용하도록 설계되어있기 때문.
- 인덱스는 테이블의 키 커럼만 가지고 있는데, ```프라이머리 키가 데이터 파일의 ROWID 역할을 한다.```
  - 인덱스를 통해 레코드를 찾는 과정 : 인덱스에 저장되어 있는 프라이머리 키 -> 프라이머리 키 인덱스 검색 -> 프라이머리 키 인덱스의 리프 페이지에 있는 레코드 조회
  - 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색으로 데이터 레코드를 읽으려면, 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야한다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제 (성능측면)
- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가, 삭제 작업 발생
#### 8.3.2.1 인덱스 키 추가
- 저장될 키 값을 이용해 B-Tree에서 적절한 위치 검색
- 저장될 위치가 정해지면, 레코드의 카 값과 주소 정보를 B-Tree의 리프 노드에 저장
- 리프 노드가 다 차는 경우 리프 노드가 분리되어야 하는데, 이 때는 브랜치 노드까지 처리 범위가 늘어나게 된다.
- 비용의 대부분은 메모리, CPU 처리 시간이 아닌 **디스크로부터 인덱스 페이지를 일고 쓰기를 해야 해서 걸리는 시간이다.⭐️**
#### 8.3.2.2 인덱스 키 삭제
- 해당 키 값이 저장된 B-Tree의 리프노드를 찾아 그냥 삭제 마크만 하면 된다.
- 삭제처리는 지연 처리로 진행한다 (버퍼 활용)
#### 8.3.2.3 인덱스 키 변경
- 키 값은 저장될 리프 노드의 위치가 결정되기 때문에, 단순히 키 값만 변경하는 것으로는 불가능하다.
- 키 값을 삭제하고 다시 새로운 키 값을 추가하는 형태로 처리된다.
- InnoDB 스토리지 엔진은 체인지 버퍼를 활용해 지연 처리로 가능하다.
#### 8.3.2.4 인덱스 키 검색
- 트리 탐색을 하는 과정이며, Select 뿐 아니라 update, delete를 위해서도 트리 탐색은 필요하다.
- innoDB 스토리지 엔진에서는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어있다.
  - ```update, delete 문장이 실행될 때 적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠구게 된다.⭐️```

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소
- B-Tree 인덱스는 인덱스 구성 칼럼 크기, 레코드 건수, 유니크 인덱스 키 값 개수 등에 의해 검색, 변경 작업의 성능이 영향을 받는다.
#### 8.3.3.1 인덱스 키 값의 크기
- 디스크에 저장하는 단위 : 페이지
- MySQL 5.7 버전부터는 페이지 크기를 ```innodb_page_size``` 시스템 변수로 설정이 가능하다.
  - 인덱스 크기에 따라 인덱스 페이지 수가 결정되는 것
  - 페이지 default 크기 : 16kb
- 인덱스 키 크기가 커지게 되면,
  - 디스크로부터 읽어야하는 횟수가 늘어나게 된다. (= 성능저하)
  - InnoDB의 버퍼풀 크기는 제한적이기 때문에, 하나의 레코드를 위한 인덱스 키가 커지면 메모리에 캐시해둘 수 있는 레코드 수는 줄어들게 된다. (= 메모리 효율 저하)
#### 8.3.3.2 B-Tree 깊이
- B-Tree 인덱스 깊이는 매우 중요하지만, 직접 제어하는 방법은 없다.
- 깊이는 값을 검색할 때 랜덤으로 디스크를 몇 번 읽어야 하는지와 직결된다.
- 일반적으로 5단계 이상까지 깊어지는 경우는 흔하지X
#### 8.3.3.3 선택도(기수성)
- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미
- 중복된 값이 많아질수록 기수성은 떨어지며, 선택도도 떨어진다.
- 선택도가 높아지면 검색 대상이 줄어들어서 빠르게 처리된다.(유니크한 값이 많아지는 경우)
  - 정렬, 그루핑 같은 작업에서는 선택도가 좋지 않아도 인덱스 설정하는 것이 유리한 경우가 있다. (상황에 따른 설계 필요)
#### 8.3.3.4 읽어야 하는 레코드 건수  
- 인덱스를 통해 테이블 레코드를 읽는 비용 > 바로 테이블의 레코드를 읽는 비용
- 인덱스를 통해 읽어야할 건수가 전체 테이블의 20~25%를 넘어가는 경우 테이블을 직접 읽어서 필요한 레코드를 가려내는 것이 더 효율적이다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기
- 어떤 경우에 인덱스를 사용하게 유도하고, 사용하지 못하게 할지 판단을 위해선 스캔 방식을 고려하자.
#### 8.3.4.1 인덱스 레인지 스캔
- 검색해야할 인덱스의 범위가 결정된 경우
- ```스캔 방식```
  - 1. 인덱스에서 조건 만족하는 값의 저장된 위치 탐색 (인덱스 탐색 - index seek)
  - 2. 1번 과정에서 탐색된 위치부터 필요한 만큼 인덱스를 읽음 (인덱스 스캔 - index scan)
  - 3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져와(from 디스크) 레코드를 읽음 
- 3번 과정을 생략하는 경우 : **커버링 인덱스**
- 인덱스를 구성하는 컬럼의 정순, 역순으로 정렬된 사앹로 레코드를 가져온다.
- 인덱스의 리프 노드에서 검색 조건에 일치하는 건은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
  - 레코드 한 건 단위로 랜덤I/O 발생⭐️
#### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우
- 인덱스 레인지 스캔보다는 느리지만, 테이블 풀 스캔보다는 효율적이다.
- 그러나, 인덱스 풀 스캔을 타거나 테이블 풀 스캔을 타는 경우 '인덱스를 (효율적으로) 사용하지 못한다.' 라고 표현...
#### 8.3.4.3 루스 인덱스 스캔 
- 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간에 필요하지 않는 인덱스 키 값은 skip 하는 방식
- group by 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용 가능 
#### 8.3.4.4. 인덱스 스킵 스캔
- 조건이 없는 인덱스의 선행 컬럼인 경우, 해당 값의 유니크한 값을 모두 조회한 뒤 주어진 쿼리 조건을 다시 실행하는 형태
- 단점
  - 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야함.
  - 쿼리가 인덱스에 존재하는 컬럼만으로 처리가 가능해야함 (커버링 인덱스)

### 8.3.5 다중 컬럼(Multi-column) 인덱스
- 인덱스는 나열된 컬럼의 순서대로 의존해 정렬이 되어있다.
- 따라서 인덱스 내에서 각 컬럼의 위치(순서)는 매우 중요하다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
#### 8.3.6.1 인덱스의 정렬
- 각 컬럼의 정렬을 오름 or 내림차순으로 설정 가능
##### 8.3.6.1.1 인덱스 스캔 방향
- 인덱스를 최솟값부터 읽으면 오름차순으로, 최댓값부터 읽으면 내림차순으로 값을 가져올 수 있다.
- 쿼리가 인덱스를 사용하는 시점에 방향을 정할 수 있다.
##### 8.3.6.1.2 내림차순 인덱스
- InnoDB에서 인덱스 연순 스캔이 인덱스 정순 스캔에 비해 느릴 수 밖에 없다.
  - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조임.
  - 페이지 내에서 인덱스 레코드는 단방향으로 연결되어 있음.
- InnoDB 페이지는 힙처럼 사용되기 때문에 물리적으로 순서대로 저장되지 않는다.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성
- where, group by, order by 절 모두 인덱스 컬럼 순서 적용은 동일하다.
#### 8.3.7.3 가용성과 효율성 판단.
```- 이 챕터는 한번씩 읽어보길 바람!```


## 8.4 R-Tree 인덱스
- 공간 인덱스 (2차원의 공간 개념 값)
- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터 검색 알고리즘 (R-Tree 알고리즘)
- 공간 데이터 연산 함수(거리 또는 포함 관계 처리)

## 8.5 전문 검색(Full Text search) 인덱스 
- 문서 전체에 대한 분석, 검색을 위한 알고리즘
- 어근 분석 알고리즘
- n-gram 알고리즘 (본문을 무조건 일정 글자씩 잘라서 인덱싱 하는 방법)

## 8.6 함수 기반 인덱스
- 컬럼의 값을 변형해서 만들어진 값에 인덱스를 설정하는 방법
- 방식
  - 가상 컬럼 이용
  - 함수 이용 
- 가상컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과 때문에, 실제 테이블의 구조가 변경된다.
- 함수 이용 : 테이블 구조를 변경하지 않고 설정할 수 있는 방법


## 8.7 멀티 밸류(Multi value) 인덱스
- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건에 1개의 인덱스 키 값을 가진다. 
- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태 (JOSN 데이터 타입)

## 8.8 클러스터링 인덱스
- 클러스터링 : 테이블의 레코드를 비슷한 것(PK 기준)끼리 묶어서 저장하는 형태
- InnoDB에서만 지원한다.
### 8.8.1 클러스터링 인덱스
- 중요한 점
  - 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다.
  - PK 값이 변경되면 레코드의 물리적인 저장 위치도 바뀌어야한다는 것을 의미
- 특징
  - 검색은 매우 빠르나, 저장/변경이 상대적으로 느리다.
- B-Tree 인덱스를 클러스터링이라고 생각할 수 있으나, 테이블 레코드가 프라이머리 키 값으로 정렬되어 저장되어 있는 경우에만 ```클러스터링 인덱스 or 클러스터링 테이블```이라고 한다.
- 클러스터링 인덱스 설정 순서
  - 1. PK가 있으면 -> PK 를 클러스터링 키로 설정
    2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째 인덱스를 클러스터링 키로 설정
    3. 자동으로 유니크한 값 가지도록, 증가 컬럼을 내부적으로 추가한 후 클러스터링 키로 설정
- InnoDB 테이블에서 클러스터링 인덱스는 테이블당 하나만 가질 수 있다!!(혜택을 누리자!!!)
### 8.8.2 세컨더리 인덱스에 미치는 영향
- 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 되어있다.⭐️
- 복잡하게 보이지만 프라이머리 키 (클러스터링 인덱스)가 주는 장점이 훨씬 많다. 성능 고민은 하지말자.
### 8.8.3 클러스터링 인덱스 장단점
| seq | 장점    |  단점   |
| -------- | -------- | -------- |
| 1  | PK로 검색하는 경우 검색성능이 매우 빠르다.   | 클러스터링 키 값이 클 경우 전체적인 인덱스 크기가 커짐(모든 세컨더리가 클러스터링 키를 갖고 있기 때문)  |
| 2  | 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에, 인덱스만으로 처리될 수 있는 경우가 많다.(커버링 인덱스)   | 세컨더리 인덱스 검색시 프라이머리 키로 다시한번 검색이 필요해 처리 성능이 느림   |
| 3  |    | insert 할 때 PK 에 의해 레코드 저장 위치가 결정되기 때문에 처리 속도가 느리다. |
| 4  |    | PK 변경할 때 레코드 delete -> insert 작업이 필요하기 때문에 처리 성능이 느리다. |

-> 장점이 더 많다고 하지 않았나요..?ㅎㅎ

### 8.8.4 클러스터링 테이블 사용 시 주의사항
1. PK 크기를 너무 크게하지 말자
  - 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키)를 포함하게 된다.
  - 그래서 PK 크기가 커지면 세컨더리 인덱스도 자동으로 커진다.
2. PK는 가능한 auto-increment보다는 업무적인 컬럼으로 생성한다.
  - PK는 의미만큼 중요한 역할이기 떄문에 검색에서 상당히 빈번하게 사용된다.
  - 그래서 그 크기가 크더라도, 업무적으로 레코드를 대표할 수 있다면 업무 컬럼을 PK로 설정하자. 
3. PK는 반드시 명시하자. 
4. auto-increment 컬럼을 인조 식별자로 사용할 경우⭐️
  - 여러 개 컬럼이 복합으로 PK로 만들어지는 경우에 세컨더리 인덱스가 필요 없다면-> 해당 컬럼을 PK로 설정하자.
  - 여러 개 컬럼 복합 PK 인데 세컨더리가 필요한 경우 -> auto-increment를 PK 로 설정하자.

## 8.9 유니크 인덱스
- NULL 저장 가능
- 인덱스 없이는 유니크 제약을 설정할 수 없다.
- 세컨더리 인덱스와 구조상 차이가 없다.
#### 8.9.1.2 유니크 인덱스 쓰기
- 쓰기할 때는 중복된 값이 있는 지 없는지 체크하는 과정이 더 필요하다.
- 이 과정에서 중복 값 체크(읽기 잠금) + 쓰기 (쓰기 잠금) 과정이 이루어지는데, 이 때 데드락이 빈번히 발생한다.
- 결론 : 유일성이 보장되어야 하는 게 아니라면, 세컨더리 인덱스로 사용하자.


## 8.10 외래키 
- 외래키 제약이 설정되면 자동으로 연관된 테이블의 컬럼에 인덱스까지 생성된다.
- 외래키 특성
  - (ON DELETE CASCADE)
  - 자식테이블에 레코드가 추가되는 경우 부모 테이블에 참조키가 있는지 확인하게 된다. 이런 체크를 위해 연관 테이블에 읽기 잠금을 걸어야한다.
- 대기하는 케이스
  - 부모 업데이트 > 자식 업데이트 하는 경우 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있으면, 쓰기 잠금이 해제될 때까지 대기한다.
  - 자식 업데이트 > 부모 삭제 하는 경우 부모는 자식의 쓰기 잠금을 대기한다.
    - on delete cascade 성격으로 부모 > 자식까지 다 삭제되어야 하기 때문

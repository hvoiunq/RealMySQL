# 인덱스
## 8.1 디스크 읽기 방식
### 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
- SSD의 장점 : 기존 HDD 보다 랜덤I/O가 훨씬 빠르다.
- 데이터 베이스 서버에서는 순차 I/O 비중보다는 작은 데이터를 읽고 쓰는 작업인 랜덤I/O 작업이 훨씬 많다.
### 8.1.2 순차I/O와 랜덤 I/O 차이
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하냐에 따라 결정됨.
  - 순차 I/O : 디스크 기록이 필요한 페이지를 모았다가 한번에 처리하는 방식.
  - 랜덤 I/O : 디스크 기록이 필요할 때마다 디스크 헤더를 움직이는 방식 (속도가 느리다.)
- RAID 컨트롤러 : 파일 동기화 작업이 너무 빈번하지 않게 도와주는 캐시 메모리를 장착한 장치.
- 쿼리 튜닝으로 랜덤I/O를 순차 I/O 로 변경할 수는 없다.
  - 랜덤 I/O자체를 줄여주는 것이 튜닝의 목적
  - 즉, 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것이다.
- 인덱스 레인지 스캔 : 주로 랜덤I/O 사용
- 풀 테이블 스캔 : 순차I/O 사용

## 8.2 인덱스란?
- 인덱스 설정 컬럼(들)과 해당 레코드가 저장된 주소를 키-밸류 형태로 저장하고 있다.
- 컬럼 값은 설정된 순서대로 미리 정렬되어 보관된다.
- SortedList 자료 구조
  - 저장되는 값을 항상 정렬된 상태로 유지
  - (장점) 조회 속도가 굉장히 빠르다 
  - (단점) 저장될 때마다 항상 값을 재정렬해야 해서 저장하는 과정이 복잡하고 느림 
  - (<->) ArrayList : 데이터파일 자료구조, 값을 저장되는 순서대로 저장
- 데이터의 저장 속도를 어디까지 희생하고, 읽기 속도를 얼마나 더 빠르게 만들지에 따라 결정해야한다.
- 역할은 프라이머리 키(Primary key), 세컨더리 인덱스(Secondary key) 로 구분할 수 있다.
  - PK는 null값과 중복값을 허용하지 않는다.
  - Secondary key는 PK를 제외한 나머지 모든 인덱스를 말하며, 그 중에서 유니크 인덱스는 PK와 성격이 비슷해 대체 키로도 불린다.
- 데이터 저장방식(알고리즘) : B-Tree 인덱스, Hash 인덱스로 구분된다.
  - B-Tree 인덱스 : 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  - Hash 인덱스 : 칼럼의 값으로 해시값을 계산해 인덱싱하는 알고리즘
    - 검색 속도가 매우 빠르나, 일부 값 검색이나 범위 검색할 때는 사용할 수 없다. ✔️
- 유니크 인덱스
  - 유니크 인덱스에 대해 동등조건으로 검색하는 경우 옵티마이저에게 1건을 찾으면 더 찾지 않아도 된다고 알려주는 효과가 있다.      

## 8.3 B-Tree 인덱스
- B-Tree의 "B" : Binary(이진)의 약자가 아닌 ```Balanced```를 의미
### 8.3.1 구조 및 특성
- 최상위에 ```루트 노드(Root node)``` 
- 가장 하위에 있는 ```리프 노드(Leaf node)```
  - 실제 데이터 레코드를 찾기 위한 주솟값을 저장하고 있음. 
- 루트와 리프 사이에 있는 ```브랜치 노드(Branch node)```
- 데이터 파일은 순서대로 저장하지 않는다. DBMS는 삭제된 공간을 재활용하도록 설계되어있다.
  - InnoDB는 레코드가 클러스터되어 디스크에 저장되기 때문에, 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.
    - 클러스터링이란? 비슷한 값을 최대한 모아서 저장하는 방식 

## 8.4 R-Tree 인덱스
## 8.5 전문 검색(Full Text search) 인덱스 
## 8.6 함수 기반 인덱스
## 8.7 멀티 밸류(Multi value) 인덱스
## 8.8 클러스터링 인덱스
## 8.9 유니크 인덱스
## 8.10 외래키 
